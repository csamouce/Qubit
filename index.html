<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Command</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #111827; --bg-med: #1f2937; --bg-light: #374151;
            --text-light: #e5e7eb; --text-med: #9ca3af;
            --accent-blue: #60a5fa; --accent-violet: #a78bfa; --accent-green: #4ade80;
            --accent-red: #f87171; --accent-yellow: #facc15; --accent-amber: #f59e0b; --accent-emerald: #34d399;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-dark); color: var(--text-light); overflow: hidden; }
        #game-container { max-width: 1000px; margin: 2vh auto; background-color: var(--bg-med); border-radius: 0.5rem; box-shadow: 0 0 25px rgba(96, 165, 250, 0.2); border: 1px solid var(--bg-light); }
        #battle-area { display: flex; justify-content: space-around; align-items: center; padding: 2rem 1rem; min-height: 350px; position: relative; border-bottom: 1px solid var(--bg-light); background: linear-gradient(160deg, #1f2937, #111827 70%); /* Angled gradient */ overflow: hidden; }
         /* Subtle animated background grid */
        #battle-area::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image: linear-gradient(var(--bg-light) 1px, transparent 1px), linear-gradient(to right, var(--bg-light) 1px, transparent 1px); background-size: 40px 40px; opacity: 0.05; animation: panGrid 30s linear infinite; z-index: 0; }
        @keyframes panGrid { 0% { background-position: 0 0; } 100% { background-position: 80px 40px; } }

        #player-side, #enemy-side { display: flex; flex-direction: column; align-items: center; width: 45%; gap: 1rem; z-index: 1; /* Above background */ }
        .unit-container { position: relative; }
        .character, .enemy { text-align: center; padding: 0.5rem; border-radius: 0.375rem; position: relative; transition: transform 0.2s ease-out, filter 0.2s ease-out; width: 100px; background-color: rgba(55, 65, 81, 0.5); border: 1px solid var(--bg-light); backdrop-filter: blur(2px); }
        .character.active-turn { transform: scale(1.1) translateY(-10px); box-shadow: 0 0 20px var(--accent-violet); border: 1px solid var(--accent-violet); z-index: 5; }
        .enemy.targeted { outline: 3px dashed var(--accent-yellow); }
        .unit-sprite { width: 60px; height: 60px; margin: 0 auto 0.5rem auto; transition: transform 0.1s ease; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); }
        .unit-container:hover .unit-sprite { transform: scale(1.1); filter: drop-shadow(0 4px 6px rgba(0,0,0,0.4)); }
        .hp-bar-container, .cp-bar-container { width: 70px; height: 6px; background-color: #4b5563; border-radius: 3px; overflow: hidden; margin: 0.25rem auto; border: 1px solid #111827; }
        .hp-bar { height: 100%; background: linear-gradient(to right, #ef4444, #f59e0b, #22c55e); transition: width 0.3s ease; }
        .cp-bar { height: 100%; background-color: var(--accent-blue); transition: width 0.3s ease; }
        .status-effect-icons { position: absolute; top: -5px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background-color: rgba(0,0,0,0.5); padding: 1px 3px; border-radius: 5px; z-index: 2; }
        .status-effect { font-size: 0.7rem; animation: pulse-status 1.5s infinite ease-in-out; }
        @keyframes pulse-status { 50% { opacity: 0.6; } }
        #action-menu { padding: 1rem; background-color: var(--bg-light); border-radius: 0 0 0.5rem 0.5rem; }
        .action-button { background-color: #4f46e5; color: white; border: none; padding: 0.5rem 0.8rem; margin: 0.25rem; border-radius: 0.25rem; cursor: pointer; transition: all 0.2s; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 2px solid #4338ca; /* Indigo-700 */ }
        .action-button:hover:not(:disabled) { background-color: #6366f1; transform: translateY(-1px); border-bottom-width: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .action-button:active:not(:disabled) { transform: translateY(0px); border-bottom-width: 2px; }
        .action-button:disabled { opacity: 0.4; cursor: not-allowed; background-color: #6b7280; border-bottom-color: #4b5563; }
        #message-log { height: 65px; overflow-y: auto; background-color: var(--bg-dark); padding: 0.5rem; border-radius: 0.25rem; margin-top: 1rem; font-size: 0.75rem; border: 1px solid #4b5563; }
        #message-log p { margin: 0 0 0.25rem 0; border-bottom: 1px dashed #374151; padding-bottom: 0.25rem; line-height: 1.4; }
        /* Damage/Effect Text & Animations */
        .effect-text { position: absolute; font-family: 'Orbitron', sans-serif; font-size: 1.2rem; font-weight: bold; text-shadow: 1px 1px 3px black; animation: floatUpAndFade 1.2s ease-out forwards; pointer-events: none; z-index: 10; }
        .damage { color: var(--accent-red); } .weakness { color: var(--accent-yellow); font-style: italic; transform: scale(1.1); } .heal { color: var(--accent-green); } .cp-gain { color: var(--accent-blue); } .status { color: var(--accent-violet); }
        @keyframes floatUpAndFade { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-70px) scale(0.8); } }
        @keyframes hit-shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-4px); } 40%, 80% { transform: translateX(4px); } }
        .hit { animation: hit-shake 0.3s ease-in-out; }
        @keyframes fade-out-dissolve { 0% { opacity: 1; filter: blur(0) grayscale(0); transform: scale(1); } 100% { opacity: 0; filter: blur(5px) grayscale(1); transform: scale(0.5); } }
        .defeated { animation: fade-out-dissolve 0.5s ease-in forwards; }
        h1, h2, button, .character .font-semibold, .enemy .font-semibold { font-family: 'Orbitron', sans-serif; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="battle-area"> <div id="player-side"></div> <div id="enemy-side"></div> </div>
        <div id="action-menu"> <div id="skill-buttons" class="flex flex-wrap justify-center"> <p class="w-full text-center text-sm text-gray-400">Select an active character to see actions.</p> </div> <div id="message-log"><p>Battle Initializing...</p></div> </div>
    </div>
    <div id="game-over-screen" class="fixed inset-0 bg-black bg-opacity-75 flex flex-col justify-center items-center hidden z-50"> <h2 id="game-over-title" class="text-4xl font-bold mb-4">Logical Error!</h2> <p id="game-over-message" class="text-xl mb-6">The quantum state decohered.</p> <button id="restart-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded text-lg">Restart Battle</button> </div>

    <script>
        // --- Game Configuration ---
        const MAX_LOG_MESSAGES = 10;
        const PLAYER_TEAM_CONFIG = [ /* ... Player team config ... */
            { id: 'lq1', name: 'Logical Qubit', type: 'LQ', hp: 150, maxHp: 150, cp: 0, maxCp: 0, speed: 5, svg: 'lq_svg', skills: [], description: "The core quantum state. Must be protected!" },
            { id: 'dec1', name: 'Matcher', type: 'DEC', hp: 60, maxHp: 60, cp: 40, maxCp: 40, speed: 10, svg: 'dec_svg', skills: ['analyze', 'correct_x', 'correct_z'], description: "Basic decoder, good at standard corrections." },
            { id: 'stab1', name: 'Stabilizer', type: 'STAB', hp: 50, maxHp: 50, cp: 50, maxCp: 50, speed: 8, svg: 'stab_svg', skills: ['analyze', 'pinpoint', 'expose_weakness'], description: "Analyzes errors and identifies weaknesses." },
            { id: 'dqlr1', name: 'Purifier', type: 'DQLR', hp: 55, maxHp: 55, cp: 45, maxCp: 45, speed: 7, svg: 'dqlr_svg', skills: ['purge_leakage', 'restore_coherence'], description: "Specializes in removing Leakage and restoring stability." }
        ];
        const ENEMY_TYPES = { /* ... Enemy types config ... */
            'X': { name: 'X-Flip Glitch', hp: 30, speed: 9, svg: 'x_err_svg', attacks: [{ type: 'damage', power: 10, target: 'lq' }], weakness: 'Z', resistance: 'X', description: "A basic bit-flip error." },
            'Z': { name: 'Z-Phase Warp', hp: 30, speed: 9, svg: 'z_err_svg', attacks: [{ type: 'damage', power: 10, target: 'lq' }], weakness: 'X', resistance: 'Z', description: "A basic phase-flip error." },
            'L': { name: 'Leakage Phantom', hp: 50, speed: 6, svg: 'l_err_svg', attacks: [{ type: 'status', effect: 'decohere', duration: 3, target: 'lq' }, { type: 'buff', effect: 'empower', target: 'allies' }], weakness: 'DQLR', resistance: null, description: "Drains stability and empowers other errors. Weak to Purging." },
            'C': { name: 'Correlated Noise', hp: 80, speed: 5, svg: 'c_err_svg', attacks: [{ type: 'damage', power: 18, target: 'lq' }, { type: 'summon', enemyType: ['X', 'Z'], count: 1, target: 'self' }], weakness: null, resistance: null, description: "A complex error source, can summon basic errors." }
        };
        const SKILLS = { /* ... Skills config ... */
            'analyze': { name: 'Analyze', cost: 2, target: 'enemy', effect: 'analyze', power: 0, description: "Scan error: reveals HP & status.", anim: 'scan' },
            'correct_x': { name: 'Correct X', cost: 5, target: 'enemy', effect: 'damage', power: 18, type: 'X', description: "Corrects X-type errors. Weak vs Z.", anim: 'beam_red' },
            'correct_z': { name: 'Correct Z', cost: 5, target: 'enemy', effect: 'damage', power: 18, type: 'Z', description: "Corrects Z-type errors. Weak vs X.", anim: 'beam_violet' },
            'purge_leakage': { name: 'Purge Leakage', cost: 8, target: 'enemy', effect: 'damage', power: 30, type: 'DQLR', description: "Effective vs Leakage Phantoms.", anim: 'cleanse_yellow' },
            'restore_coherence': { name: 'Restore Stability', cost: 10, target: 'ally', effect: 'heal', power: 30, type: 'DQLR', description: "Restores Stability (HP).", anim: 'heal_green' },
            'pinpoint': { name: 'Pinpoint', cost: 6, target: 'enemy', effect: 'status', statusType: 'measured', duration: 3, power: 0.5, description: "Mark error as 'Measured', lowering defense.", anim: 'target_lock' }, // Measured power = defense multiplier increase
            'expose_weakness': { name: 'Expose Weakness', cost: 7, target: 'enemy', effect: 'reveal_weakness', power: 0, description: "Reveal error's weakness/resistance.", anim: 'scan_detailed' },
        };
        const WEAKNESS_CP_REFUND = 3; // Increased CP refund

        // --- SVG Definitions ---
        const SVG_SPRITES = { /* ... SVG strings ... */
            'lq_svg': `<svg viewBox="0 0 100 100"><defs><radialGradient id="gradLQ" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#a5f3fc" stop-opacity="1"/><stop offset="100%" stop-color="#60a5fa" stop-opacity="1"/></radialGradient></defs><circle cx="50" cy="50" r="40" fill="url(#gradLQ)"/><circle cx="50" cy="50" r="45" fill="none" stroke="#a5f3fc" stroke-width="3" stroke-dasharray="5 5"><animate attributeName="stroke-dashoffset" values="0;100" dur="5s" repeatCount="indefinite"/></circle></svg>`,
            'dec_svg': `<svg viewBox="0 0 100 100"><path d="M50 10 L90 50 L50 90 L10 50 Z" fill="#a78bfa" stroke="#c4b5fd" stroke-width="3"/><path d="M50 20 L80 50 L50 80 L20 50 Z" fill="none" stroke="#1f2937" stroke-width="2"/></svg>`,
            'stab_svg': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="30" fill="none" stroke="#34d399" stroke-width="5"/><path d="M50 10 V30 M50 70 V90 M10 50 H30 M70 50 H90" stroke="#34d399" stroke-width="5"/><circle cx="50" cy="50" r="10" fill="#34d399"/></svg>`,
            'dqlr_svg': `<svg viewBox="0 0 100 100"><path d="M20 80 A 40 40 0 0 1 80 80 L 50 20 Z" fill="#fbbf24" stroke="#fcd34d" stroke-width="3"/><path d="M35 75 A 20 20 0 0 1 65 75 L 50 40 Z" fill="none" stroke="#1f2937" stroke-width="2"/></svg>`,
            'x_err_svg': `<svg viewBox="0 0 100 100"><path d="M20 20 L80 80 M80 20 L20 80" stroke="#f43f5e" stroke-width="12" stroke-linecap="round"/><path d="M25 25 L75 75 M75 25 L25 75" stroke="#fecdd3" stroke-width="4" stroke-linecap="round"/></svg>`,
            'z_err_svg': `<svg viewBox="0 0 100 100"><path d="M20 25 H80 L20 75 H80" stroke="#8b5cf6" stroke-width="12" fill="none" stroke-linejoin="round" stroke-linecap="round"/><path d="M25 30 H75 L25 70 H75" stroke="#ddd6fe" stroke-width="4" fill="none" stroke-linejoin="round" stroke-linecap="round"/></svg>`,
            'l_err_svg': `<svg viewBox="0 0 100 100"><path d="M50 10 C 20 30, 20 70, 50 90 C 80 70, 80 30, 50 10 Z" fill="#f59e0b" opacity="0.7"/><path d="M50 20 C 30 40, 30 60, 50 80 C 70 60, 70 40, 50 20 Z" fill="#1f2937" opacity="0.8"/></svg>`,
            'c_err_svg': `<svg viewBox="0 0 100 100"><circle cx="35" cy="35" r="20" fill="#ef4444"/><circle cx="65" cy="65" r="20" fill="#ef4444"/><path d="M45 45 L55 55" stroke="#f87171" stroke-width="8"/><circle cx="35" cy="35" r="25" stroke="#f87171" stroke-width="4" fill="none"/><circle cx="65" cy="65" r="25" stroke="#f87171" stroke-width="4" fill="none"/></svg>`
         };

        // --- Game State ---
        let playerTeam = []; let enemies = []; let turnOrder = [];
        let currentTurnIndex = 0; let selectedCharacterId = null; let selectedSkill = null; let selectedTargetId = null;
        let messageLog = []; let gameOver = false;

        // --- DOM Elements ---
        const playerSideEl = document.getElementById('player-side'); const enemySideEl = document.getElementById('enemy-side');
        const skillButtonsEl = document.getElementById('skill-buttons'); const messageLogEl = document.getElementById('message-log');
        const gameOverScreen = document.getElementById('game-over-screen'); const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message'); const restartBtn = document.getElementById('restart-btn');

        // --- Sound Initialization ---
        let soundEnabled = false; let synth, noiseSynth; // Add more as needed
        function setupSounds() { /* ... */ synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination(); console.log("Audio context started."); soundEnabled = true; }
        function playSound(type) { /* ... */ if (!soundEnabled) return; try { const now = Tone.now(); switch(type) { case 'select': synth.triggerAttackRelease('C5', '32n', now); break; case 'confirm': synth.triggerAttackRelease('E5', '16n', now); break; case 'cancel': synth.triggerAttackRelease('C4', '16n', now); break; case 'player_attack': noiseSynth.triggerAttackRelease('8n', now); synth.triggerAttackRelease('A4', '8n', now + 0.01); break; case 'enemy_attack': noiseSynth.triggerAttackRelease('8n', now + 0.05); synth.triggerAttackRelease('D3', '8n', now + 0.06); break; case 'heal': synth.triggerAttackRelease('C6', '8n', now); break; case 'buff': synth.triggerAttackRelease('E5', '16n', now); synth.triggerAttackRelease('G5', '16n', now + 0.1); break; case 'debuff': synth.triggerAttackRelease('F#3', '8n', now); break; case 'weakness_hit': synth.triggerAttackRelease('B5', '8n', now); noiseSynth.triggerAttackRelease('16n', now + 0.02); break; case 'error_defeated': noiseSynth.triggerAttackRelease('4n', now); synth.triggerAttackRelease('C3', '4n', now + 0.05); break; case 'game_over': noiseSynth.triggerAttackRelease('1n', now); synth.triggerAttackRelease('A1', '1n', now); break; case 'battle_start': synth.triggerAttackRelease('C4', '8n'); synth.triggerAttackRelease('E4', '8n', now+0.2); synth.triggerAttackRelease('G4', '8n', now+0.4); break; } } catch (e) { console.error("Sound playback error:", e); } }
        function initAudio() { /* ... */ if (!soundEnabled && Tone.context.state !== 'running') { Tone.start().then(setupSounds); } else if (!soundEnabled && Tone.context.state === 'running') { setupSounds(); } window.removeEventListener('click', initAudio); window.removeEventListener('keydown', initAudio); }
        window.addEventListener('click', initAudio, { once: true }); window.addEventListener('keydown', initAudio, { once: true });


        // --- Game Logic Functions ---

        function startGame() { /* ... reset state ... */
            gameOver = false; gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('show'); messageLog = []; logMessage("Quantum Battle Initialized!");
            playerTeam = JSON.parse(JSON.stringify(PLAYER_TEAM_CONFIG));
            enemies = [ createEnemy('X'), createEnemy('Z'), createEnemy('L') ]; if (Math.random() < 0.2) enemies.push(createEnemy('X'));
            setupTurnOrder(); currentTurnIndex = -1; selectedCharacterId = null; selectedSkill = null; selectedTargetId = null;
            drawBattleState(); updateActionMenu(); playSound('battle_start');
            // Use requestAnimationFrame for smoother turn transition check
            requestAnimationFrame(nextTurn); // Start the first turn
        }

        function createEnemy(type) { /* ... */ const base = ENEMY_TYPES[type]; if (!base) return null; return { ...JSON.parse(JSON.stringify(base)), id: `enemy_${type}_${Math.random().toString(16).slice(2)}`, currentHp: base.hp, statusEffects: [] }; }
        function setupTurnOrder() { /* ... */ turnOrder = [...playerTeam, ...enemies].sort((a, b) => b.speed - a.speed); console.log("Turn order:", turnOrder.map(u => u.name)); }
        function getCurrentUnit(index = currentTurnIndex) { /* ... */ if (gameOver || turnOrder.length === 0) return null; return turnOrder[index % turnOrder.length]; }

        function nextTurn() {
            if (gameOver) return;
            console.log(`Entering nextTurn. Current index: ${currentTurnIndex}`);

            // --- Pre-Turn Processing ---
            const previousUnit = getCurrentUnit(); // Unit from *previous* index
            if (previousUnit) {
                 const prevUnitEl = document.getElementById(previousUnit.id);
                 if (prevUnitEl) prevUnitEl.classList.remove('active-turn');
            }
            selectedCharacterId = null; selectedSkill = null; selectedTargetId = null; // Clear selections

            applyStatusEffects(); // Apply DoTs, check durations

            // --- Check Win/Loss Conditions ---
            if (enemies.length === 0) { endGame(true, "All errors corrected!"); return; }
            const lq = playerTeam.find(c => c.type === 'LQ');
            if (!lq || lq.hp <= 0) { endGame(false, "Logical Qubit Decohered!"); return; }

            // --- Advance Turn ---
            currentTurnIndex++;
            if (currentTurnIndex >= turnOrder.length) {
                currentTurnIndex = 0;
                logMessage("--- New Round ---");
                playerTeam.forEach(p => { if(p.type !== 'LQ') p.cp = Math.min(p.maxCp, p.cp + 5); }); // CP Regen
                 // Re-sort turn order potentially? For now, keep it fixed per battle.
            }

            // --- Get Current Unit & Validate ---
            const currentUnit = getCurrentUnit();
            if (!currentUnit) {
                 console.error("CRITICAL: Could not get current unit!", currentTurnIndex, turnOrder);
                 logMessage("Error: Turn desynchronized!");
                 // Attempt to recover by resetting index?
                 currentTurnIndex = 0;
                 requestAnimationFrame(nextTurn); // Try again immediately
                 return;
            }

            // Check if the unit that's supposed to act still exists
            const unitStillExists = playerTeam.some(p => p.id === currentUnit.id) || enemies.some(e => e.id === currentUnit.id);
            if (!unitStillExists) {
                console.log(`Unit ${currentUnit.id} (${currentUnit.name}) was defeated before its turn. Skipping.`);
                // Don't increment index again, just call nextTurn to process the *next* index
                requestAnimationFrame(nextTurn);
                return;
            }

            // --- Process Turn ---
            logMessage(`Turn: ${currentUnit.name}`);
            const activeUnitEl = document.getElementById(currentUnit.id);
            if (activeUnitEl) activeUnitEl.classList.add('active-turn');

            if (playerTeam.some(p => p.id === currentUnit.id)) { // Player Turn
                selectedCharacterId = currentUnit.id;
                updateActionMenu(); // Enable actions for this player unit
            } else { // Enemy Turn
                updateActionMenu(); // Disable player actions
                setTimeout(enemyAI, 1200); // Delay for enemy action
            }
            drawBattleState();
            console.log(`Exiting nextTurn for ${currentUnit.name}`);
        }


        function applyStatusEffects() { /* ... same logic, ensure drawBattleState is called if HP changes ... */
             let hpChanged = false;
             [...playerTeam, ...enemies].forEach(unit => {
                 unit.statusEffects = unit.statusEffects?.filter(effect => {
                     let effectExpired = false;
                     switch(effect.effect) {
                         case 'decohere':
                             const lq = playerTeam.find(c => c.type === 'LQ');
                             if (lq && lq.hp > 0) {
                                 const damage = Math.max(1, Math.floor(lq.maxHp * 0.05));
                                 lq.hp = Math.max(0, lq.hp - damage); hpChanged = true;
                                 logMessage(`${unit.name}'s ${effect.effect} damages LQ for ${damage} Stability!`); showEffectText(lq.id, `-${damage}`, 'damage');
                             } break;
                     }
                     effect.duration--;
                     if(effect.duration <= 0) { logMessage(`${unit.name}'s ${effect.effect} effect wore off.`); effectExpired = true; }
                     return !effectExpired;
                 }) || [];
             });
             if (hpChanged) drawBattleState(); // Redraw only if HP changed
        }

        function enemyAI() { /* ... same logic, ensure nextTurn is scheduled via requestAnimationFrame ... */
             if (gameOver) return;
             const enemy = getCurrentUnit();
             if (!enemy || playerTeam.some(p => p.id === enemy.id)) { console.warn("Enemy AI called, but not enemy turn?"); requestAnimationFrame(nextTurn); return; }
             if (!enemies.some(e => e.id === enemy.id)) { console.log(`Enemy ${enemy.name} defeated before action.`); requestAnimationFrame(nextTurn); return; }

             const availableAttacks = enemy.attacks; if (!availableAttacks || availableAttacks.length === 0) { logMessage(`${enemy.name} hesitates.`); requestAnimationFrame(nextTurn); return; }
             const attack = availableAttacks[Math.floor(Math.random() * availableAttacks.length)]; let target = null;
             // Targeting logic...
             if (attack.target === 'lq') { target = playerTeam.find(c => c.type === 'LQ'); }
             else if (attack.target === 'random_player') { const pTargets = playerTeam.filter(p => p.hp > 0); if (pTargets.length > 0) target = pTargets[Math.floor(Math.random() * pTargets.length)]; }
             else if (attack.target === 'self') { target = enemy; }
             else if (attack.target === 'allies') { logMessage(`${enemy.name} empowers allies!`); playSound('buff'); requestAnimationFrame(nextTurn); return; }
             else if (attack.type === 'summon') { /* Summon logic ... */ for (let i=0; i < attack.count; i++) { const typeToSummon = attack.enemyType[Math.floor(Math.random() * attack.enemyType.length)]; const newEnemy = createEnemy(typeToSummon); if (newEnemy && enemies.length < 4) { enemies.push(newEnemy); logMessage(`${enemy.name} summons a ${newEnemy.name}!`); turnOrder.push(newEnemy); } } drawBattleState(); requestAnimationFrame(nextTurn); return; }

             if (target && target.hp > 0) {
                 logMessage(`${enemy.name} uses ${attack.type || attack.effect} on ${target.name}.`); playSound('enemy_attack');
                 animateAttack(enemy.id, target.id, 'enemy');
                 executeAction(enemy, attack, target);
             } else { logMessage(`${enemy.name} finds no valid target.`); }

             requestAnimationFrame(nextTurn); // Use rAF instead of setTimeout
        }

        function confirmAction() { /* ... ensure nextTurn is scheduled via requestAnimationFrame ... */
            playSound('confirm');
            const character = playerTeam.find(c => c.id === selectedCharacterId);
            const skill = SKILLS[selectedSkill];
            const target = turnOrder.find(u => u.id === selectedTargetId);

            if (character && skill && target && character.cp >= skill.cost) {
                character.cp -= skill.cost;
                logMessage(`${character.name} uses ${skill.name} on ${target.name}!`); playSound('player_attack');
                animateAttack(character.id, target.id, 'player', skill.anim);
                executeAction(character, skill, target);

                selectedSkill = null; selectedTargetId = null;
                updateActionMenu(); // Disable buttons
                drawBattleState();
                requestAnimationFrame(nextTurn); // Use rAF
            } else { /* ... cancel logic ... */ logMessage("Action failed."); playSound('cancel'); selectedSkill = null; selectedTargetId = null; updateActionMenu(); drawBattleState(); }
        }


        function executeAction(source, action, target) { /* ... weakness refund logic ... */
             let damage = 0; let effectApplied = false; let hitWeakness = false; let cpRefund = 0;
             let powerMultiplier = 1.0; source.statusEffects?.forEach(eff => { if (eff.effect === 'empower') powerMultiplier *= 1.5; });
             let defenseMultiplier = 1.0; target.statusEffects?.forEach(eff => { if (eff.effect === 'defense_down' || eff.effect === 'measured') defenseMultiplier *= (1 + (eff.power || 0.5)); });

             switch(action.effect) {
                 case 'damage':
                     damage = Math.floor(action.power * powerMultiplier * defenseMultiplier);
                     const targetInfo = ENEMY_TYPES[target.type];
                     if (targetInfo) {
                         if (targetInfo.weakness === action.type) { damage = Math.floor(damage * 1.6); hitWeakness = true; logMessage("Weakness hit!"); playSound('weakness_hit'); cpRefund = WEAKNESS_CP_REFUND; }
                         else if (targetInfo.resistance === action.type) { damage = Math.floor(damage * 0.5); logMessage("Resisted!"); }
                     }
                     target.hp = Math.max(0, target.hp - damage);
                     logMessage(`${target.name} takes ${damage} damage.`); showEffectText(target.id, `-${damage}`, 'damage' + (hitWeakness ? ' weakness' : '')); animateHit(target.id);
                     if (target.hp <= 0) { handleDefeat(target); }
                     break;
                 case 'heal': const healAmount = Math.floor(action.power * powerMultiplier); target.hp = Math.min(target.maxHp, target.hp + healAmount); logMessage(`${target.name} recovers ${healAmount} Stability.`); playSound('heal'); showEffectText(target.id, `+${healAmount}`, 'heal'); break;
                 case 'status': const statusType = action.statusType || action.effect; target.statusEffects = target.statusEffects?.filter(eff => eff.effect !== statusType) || []; target.statusEffects.push({ effect: statusType, duration: action.duration, power: action.power }); logMessage(`${target.name} is affected by ${statusType}!`); playSound(statusType === 'empower' ? 'buff' : 'debuff'); showEffectText(target.id, `${statusType.toUpperCase()}!`, 'status'); effectApplied = true; break;
                 case 'reveal_weakness': const enemyTypeInfoW = ENEMY_TYPES[target.type]; if (enemyTypeInfoW) { logMessage(`${target.name} Weak: ${enemyTypeInfoW.weakness || 'N/A'}. Res: ${enemyTypeInfoW.resistance || 'N/A'}.`); showEffectText(target.id, `Weak: ${enemyTypeInfoW.weakness || 'N/A'}`, 'status'); } else { logMessage(`Analysis failed.`); } playSound('buff'); effectApplied = true; break;
                 case 'analyze': logMessage(`${target.name} HP: ${target.hp}/${target.maxHp}`); showEffectText(target.id, `HP ${target.hp}/${target.maxHp}`, 'status'); playSound('buff'); effectApplied = true; break;
             }
             if (hitWeakness && playerTeam.some(p => p.id === source.id)) { source.cp = Math.min(source.maxCp, source.cp + cpRefund); logMessage(`${source.name} recovers ${cpRefund} CP!`); showEffectText(source.id, `+${cpRefund} CP`, 'cp-gain'); }
             drawBattleState();
        }

        function handleDefeat(unit) {
            logMessage(`${unit.name} is corrected!`);
            playSound('error_defeated');
            showEffectText(unit.id, 'Corrected!', 'heal');

            const unitElement = document.getElementById(unit.id);
            if (unitElement) {
                unitElement.classList.add('defeated'); // Apply animation class
                // Remove the unit from the *logic* immediately
                const wasEnemy = enemies.some(e => e.id === unit.id);
                if (wasEnemy) {
                    enemies = enemies.filter(e => e.id !== unit.id);
                } else {
                     // Handle player defeat? For now, only LQ defeat matters for game over.
                }
                // Remove from turn order *after* current turn potentially finishes
                // Let nextTurn handle skipping if the unit is gone
                // Remove the element after animation
                 setTimeout(() => {
                     unitElement.remove();
                     // Maybe rebuild turn order here if needed? Or let nextTurn handle it.
                     // Rebuilding turn order mid-round can be complex.
                     // Let's try letting nextTurn skip the defeated unit.
                 }, 500); // Match defeat animation duration
            } else {
                 // Failsafe if element not found
                 enemies = enemies.filter(e => e.id !== unit.id);
                 // Consider rebuilding turn order here too
                 setupTurnOrder(); // Rebuild if element wasn't found
                 drawBattleState();
            }
        }


        function showEffectText(targetId, text, typeClass = 'damage') { /* ... */ const targetElement = document.getElementById(targetId); if (!targetElement) return; const effectEl = document.createElement('div'); effectEl.className = `effect-text ${typeClass}`; effectEl.textContent = text; document.getElementById('battle-area').appendChild(effectEl); const rect = targetElement.getBoundingClientRect(); const containerRect = document.getElementById('battle-area').getBoundingClientRect(); effectEl.style.left = `${rect.left - containerRect.left + rect.width / 2}px`; effectEl.style.top = `${rect.top - containerRect.top}px`; setTimeout(() => { effectEl.remove(); }, 1200); }
        function logMessage(message) { /* ... */ console.log(message); messageLog.push(message); if (messageLog.length > MAX_LOG_MESSAGES * 2) { messageLog.shift(); } const logHtml = messageLog.slice(-MAX_LOG_MESSAGES).map(m => `<p>${m}</p>`).join(''); messageLogEl.innerHTML = logHtml; messageLogEl.scrollTop = messageLogEl.scrollHeight; }

        // --- Drawing & Animation Functions ---
        function drawBattleState() { /* ... */ playerSideEl.innerHTML = ''; playerTeam.forEach(p => playerSideEl.appendChild(createUnitElement(p, true))); enemySideEl.innerHTML = ''; enemies.forEach(e => enemySideEl.appendChild(createUnitElement(e, false))); document.querySelectorAll('.enemy, .character').forEach(el => el.classList.remove('targeted')); if (selectedSkill && selectedTargetId) { const targetEl = document.getElementById(selectedTargetId); if (targetEl) targetEl.classList.add('targeted'); } else if (selectedSkill) { const skillInfo = SKILLS[selectedSkill]; const potentialTargets = turnOrder.filter(unit => { if (skillInfo.target === 'enemy') return enemies.some(e => e.id === unit.id); if (skillInfo.target === 'ally') return playerTeam.some(p => p.id === unit.id); if (skillInfo.target === 'self') return unit.id === selectedCharacterId; return false; }); potentialTargets.forEach(unit => { const el = document.getElementById(unit.id); if (el) el.classList.add('targeted'); }); } const currentUnit = getCurrentUnit(); if (currentUnit) { const activeUnitEl = document.getElementById(currentUnit.id); if (activeUnitEl) activeUnitEl.classList.add('active-turn'); } }
        function createUnitElement(unit, isPlayer) { /* ... Use SVG_SPRITES map ... */ const container = document.createElement('div'); container.className = 'unit-container'; container.id = unit.id; const div = document.createElement('div'); div.className = `unit ${isPlayer ? 'character' : 'enemy'} ${isPlayer ? 'char-' + unit.type : 'enemy-' + unit.type}`; if (!isPlayer) { div.onclick = () => { if(selectedSkill) selectTarget(unit.id); }; div.style.cursor = selectedSkill ? 'pointer' : 'default'; } else { div.onclick = () => { if(selectedSkill && SKILLS[selectedSkill].target === 'ally') selectTarget(unit.id); }; div.style.cursor = (selectedSkill && SKILLS[selectedSkill].target === 'ally') ? 'pointer' : 'default'; } const spriteDiv = document.createElement('div'); spriteDiv.className = 'unit-sprite'; spriteDiv.innerHTML = SVG_SPRITES[unit.svg || (isPlayer ? 'lq_svg' : 'x_err_svg')]; div.appendChild(spriteDiv); const name = document.createElement('div'); name.className = 'text-sm font-semibold'; name.textContent = unit.name; div.appendChild(name); const hpContainer = document.createElement('div'); hpContainer.className = 'hp-bar-container'; const hpBar = document.createElement('div'); hpBar.className = 'hp-bar'; hpBar.style.width = `${Math.max(0, (unit.hp / unit.maxHp) * 100)}%`; hpContainer.appendChild(hpBar); div.appendChild(hpContainer); const hpText = document.createElement('div'); hpText.className = 'text-xs text-gray-400'; hpText.textContent = `${unit.hp}/${unit.maxHp}`; div.appendChild(hpText); if (isPlayer && unit.type !== 'LQ') { const cpContainer = document.createElement('div'); cpContainer.className = 'cp-bar-container'; const cpBar = document.createElement('div'); cpBar.className = 'cp-bar'; cpBar.style.width = `${Math.max(0, (unit.cp / unit.maxCp) * 100)}%`; cpContainer.appendChild(cpBar); div.appendChild(cpContainer); const cpText = document.createElement('div'); cpText.className = 'text-xs text-gray-400'; cpText.textContent = `${unit.cp}/${unit.maxCp}`; div.appendChild(cpText); } const statusIconsContainer = document.createElement('div'); statusIconsContainer.className = 'status-effect-icons'; unit.statusEffects?.forEach(eff => { const statusIcon = document.createElement('i'); let iconClass = ''; let colorClass = ''; switch(eff.effect) { case 'decohere': iconClass = 'fa-arrow-trend-down'; colorClass = 'text-red-500'; break; case 'defense_down': case 'measured': iconClass = 'fa-shield-slash'; colorClass = 'text-yellow-500'; break; case 'empower': iconClass = 'fa-bolt'; colorClass = 'text-blue-400'; break; } if (iconClass) { statusIcon.className = `fas ${iconClass} ${colorClass} status-effect`; statusIcon.title = `${eff.effect} (${eff.duration} turns left)`; statusIconsContainer.appendChild(statusIcon); } }); container.appendChild(statusIconsContainer); container.appendChild(div); return container; }
        function updateActionMenu() { /* ... remains the same ... */ skillButtonsEl.innerHTML = ''; const character = playerTeam.find(c => c.id === selectedCharacterId); if (character && character.type !== 'LQ') { character.skills.forEach(skillId => { const skill = SKILLS[skillId]; if (!skill) return; const button = document.createElement('button'); button.className = 'action-button'; button.textContent = `${skill.name} (${skill.cost} CP)`; button.disabled = character.cp < skill.cost || !!selectedSkill; button.onclick = () => selectSkill(skillId); skillButtonsEl.appendChild(button); }); if (selectedSkill && selectedTargetId) { const confirmBtn = document.createElement('button'); confirmBtn.className = 'action-button bg-green-600 hover:bg-green-700'; confirmBtn.textContent = 'Confirm'; confirmBtn.onclick = confirmAction; skillButtonsEl.appendChild(confirmBtn); const cancelBtn = document.createElement('button'); cancelBtn.className = 'action-button bg-gray-500 hover:bg-gray-600'; cancelBtn.textContent = 'Cancel'; cancelBtn.onclick = () => { playSound('cancel'); selectedSkill = null; selectedTargetId = null; updateActionMenu(); drawBattleState(); logMessage("Action cancelled."); }; skillButtonsEl.appendChild(cancelBtn); } else if (selectedSkill) { skillButtonsEl.innerHTML = `<p class="w-full text-center text-sm text-yellow-400">Select Target for ${SKILLS[selectedSkill].name}...</p>`; const cancelBtn = document.createElement('button'); cancelBtn.className = 'action-button bg-gray-500 hover:bg-gray-600'; cancelBtn.textContent = 'Cancel Skill'; cancelBtn.onclick = () => { playSound('cancel'); selectedSkill = null; updateActionMenu(); drawBattleState(); logMessage("Skill cancelled."); }; skillButtonsEl.appendChild(cancelBtn); } } else { skillButtonsEl.innerHTML = '<p class="w-full text-center text-sm text-gray-400">Waiting for turn...</p>'; } }
        function animateAttack(sourceId, targetId, attackerType, animType = 'default') { /* ... remains the same ... */ const sourceEl = document.getElementById(sourceId)?.querySelector('.unit'); const targetEl = document.getElementById(targetId)?.querySelector('.unit'); if (!sourceEl || !targetEl) return; sourceEl.style.transition = 'transform 0.1s ease-out'; const direction = (attackerType === 'player') ? 1 : -1; sourceEl.style.transform = `translateX(${direction * 20}px) scale(1.05)`; setTimeout(() => { sourceEl.style.transform = ''; }, 150); }
        function animateHit(targetId) { /* ... remains the same ... */ const targetEl = document.getElementById(targetId)?.querySelector('.unit'); if (targetEl) { targetEl.classList.add('hit'); setTimeout(() => targetEl.classList.remove('hit'), 300); } }
        function endGame(isWin, message) { /* ... remains the same ... */ if (gameOver) return; gameOver = true; playSound('game_over'); console.log("Game Over:", message); gameOverTitle.textContent = isWin ? "Correction Complete!" : "Logical Error!"; gameOverMessage.textContent = message; gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('show'); }

        // --- Initialization ---
        restartBtn.addEventListener('click', () => { playSound('click'); startGame(); });
        document.addEventListener('DOMContentLoaded', startGame);

    </script>

</body>
</html>
