<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Command</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #111827;
            --bg-med: #1f2937;
            --bg-light: #374151;
            --text-light: #e5e7eb;
            --text-med: #9ca3af;
            --accent-blue: #60a5fa;
            --accent-violet: #a78bfa;
            --accent-green: #4ade80;
            --accent-red: #f87171;
            --accent-yellow: #facc15;
            --accent-amber: #f59e0b;
            --accent-emerald: #34d399;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-dark); color: var(--text-light); overflow: hidden; }
        #game-container { max-width: 1000px; margin: 2vh auto; background-color: var(--bg-med); border-radius: 0.5rem; box-shadow: 0 0 25px rgba(96, 165, 250, 0.2); border: 1px solid var(--bg-light); }
        #battle-area { display: flex; justify-content: space-around; align-items: center; padding: 2rem 1rem; min-height: 350px; /* Taller battle area */ position: relative; border-bottom: 1px solid var(--bg-light); background: linear-gradient(to bottom, #1f2937, #111827); /* Dark gradient bg */ overflow: hidden; }
        #player-side, #enemy-side { display: flex; flex-direction: column; align-items: center; width: 45%; /* Slightly wider */ gap: 1rem; /* Space between units */ }
        .unit-container { position: relative; /* For status effects */ }
        .character, .enemy { text-align: center; padding: 0.5rem; border-radius: 0.375rem; position: relative; transition: transform 0.2s ease-out, filter 0.2s ease-out; width: 100px; /* Fixed width */ background-color: rgba(55, 65, 81, 0.3); border: 1px solid var(--bg-light); }
        .character.active-turn { transform: scale(1.1) translateY(-10px); box-shadow: 0 0 20px var(--accent-violet); border: 1px solid var(--accent-violet); z-index: 5; }
        .enemy.targeted { outline: 3px dashed var(--accent-yellow); }
        .unit-sprite { width: 60px; height: 60px; margin: 0 auto 0.5rem auto; transition: transform 0.1s ease; }
        .unit-container:hover .unit-sprite { transform: scale(1.1); } /* Hover effect */
        .hp-bar-container, .cp-bar-container { width: 70px; height: 6px; background-color: #4b5563; border-radius: 3px; overflow: hidden; margin: 0.25rem auto; border: 1px solid #111827; }
        .hp-bar { height: 100%; background: linear-gradient(to right, #ef4444, #f59e0b, #22c55e); /* Red->Yellow->Green */ transition: width 0.3s ease; } /* Gradient HP */
        .cp-bar { height: 100%; background-color: var(--accent-blue); transition: width 0.3s ease; }
        .status-effect-icons { position: absolute; top: -5px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background-color: rgba(0,0,0,0.5); padding: 1px 3px; border-radius: 5px; }
        .status-effect { font-size: 0.7rem; /* Smaller icons */ animation: pulse-status 1.5s infinite ease-in-out; }
        @keyframes pulse-status { 50% { opacity: 0.6; } }
        #action-menu { padding: 1rem; background-color: var(--bg-light); border-radius: 0 0 0.5rem 0.5rem; }
        .action-button { background-color: #4f46e5; /* indigo-600 */ color: white; border: none; padding: 0.5rem 0.8rem; margin: 0.25rem; border-radius: 0.25rem; cursor: pointer; transition: all 0.2s; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        .action-button:hover:not(:disabled) { background-color: #6366f1; /* indigo-500 */ transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .action-button:disabled { opacity: 0.4; cursor: not-allowed; background-color: #6b7280; }
        #message-log { height: 65px; overflow-y: auto; background-color: var(--bg-dark); padding: 0.5rem; border-radius: 0.25rem; margin-top: 1rem; font-size: 0.75rem; border: 1px solid #4b5563; }
        #message-log p { margin: 0 0 0.25rem 0; border-bottom: 1px dashed #374151; padding-bottom: 0.25rem; line-height: 1.4; }
        /* Damage/Effect Text & Animations */
        .effect-text { position: absolute; font-size: 1.2rem; font-weight: bold; text-shadow: 1px 1px 3px black; animation: floatUpAndFade 1.2s ease-out forwards; pointer-events: none; z-index: 10; }
        .damage { color: var(--accent-red); }
        .weakness { color: var(--accent-yellow); font-style: italic; }
        .heal { color: var(--accent-green); }
        .cp-gain { color: var(--accent-blue); }
        .status { color: var(--accent-violet); }
        @keyframes floatUpAndFade { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-70px) scale(0.8); } }
        /* Hit Animation */
        @keyframes hit-shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-4px); } 40%, 80% { transform: translateX(4px); } }
        .hit { animation: hit-shake 0.3s ease-in-out; }
        /* Defeat Animation */
        @keyframes fade-out-dissolve { 0% { opacity: 1; filter: blur(0); transform: scale(1); } 100% { opacity: 0; filter: blur(5px); transform: scale(0.5); } }
        .defeated { animation: fade-out-dissolve 0.5s ease-in forwards; }

        /* Stylish Font */
        h1, h2, button, .character .font-semibold, .enemy .font-semibold { font-family: 'Orbitron', sans-serif; /* Sci-fi font */ }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="battle-area">
            <div id="player-side"></div>
            <div id="enemy-side"></div>
        </div>
        <div id="action-menu">
            <div id="skill-buttons" class="flex flex-wrap justify-center">
                <p class="w-full text-center text-sm text-gray-400">Select an active character to see actions.</p>
            </div>
            <div id="message-log"><p>Battle Initializing...</p></div>
        </div>
    </div>

    <div id="game-over-screen" class="fixed inset-0 bg-black bg-opacity-75 flex flex-col justify-center items-center hidden z-50">
        <h2 id="game-over-title" class="text-4xl font-bold mb-4">Logical Error!</h2>
        <p id="game-over-message" class="text-xl mb-6">The quantum state decohered.</p>
        <button id="restart-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded text-lg">Restart Battle</button>
    </div>

    <script>
        // --- Game Configuration ---
        const MAX_LOG_MESSAGES = 10;
        const PLAYER_TEAM_CONFIG = [ // Use CONFIG to allow reset
            { id: 'lq1', name: 'Logical Qubit', type: 'LQ', hp: 150, maxHp: 150, cp: 0, maxCp: 0, speed: 5, svg: 'lq_svg', skills: [], description: "The core quantum state. Must be protected!" },
            { id: 'dec1', name: 'Matcher', type: 'DEC', hp: 60, maxHp: 60, cp: 40, maxCp: 40, speed: 10, svg: 'dec_svg', skills: ['analyze', 'correct_x', 'correct_z'], description: "Basic decoder, good at standard corrections." },
            { id: 'stab1', name: 'Stabilizer', type: 'STAB', hp: 50, maxHp: 50, cp: 50, maxCp: 50, speed: 8, svg: 'stab_svg', skills: ['analyze', 'pinpoint', 'expose_weakness'], description: "Analyzes errors and identifies weaknesses." },
            { id: 'dqlr1', name: 'Purifier', type: 'DQLR', hp: 55, maxHp: 55, cp: 45, maxCp: 45, speed: 7, svg: 'dqlr_svg', skills: ['purge_leakage', 'restore_coherence'], description: "Specializes in removing Leakage and restoring stability." }
        ];
        const ENEMY_TYPES = {
            'X': { name: 'X-Flip Glitch', hp: 30, speed: 9, svg: 'x_err_svg', attacks: [{ type: 'damage', power: 10, target: 'lq' }], weakness: 'Z', resistance: 'X', description: "A basic bit-flip error." },
            'Z': { name: 'Z-Phase Warp', hp: 30, speed: 9, svg: 'z_err_svg', attacks: [{ type: 'damage', power: 10, target: 'lq' }], weakness: 'X', resistance: 'Z', description: "A basic phase-flip error." },
            'L': { name: 'Leakage Phantom', hp: 50, speed: 6, svg: 'l_err_svg', attacks: [{ type: 'status', effect: 'decohere', duration: 3, target: 'lq' }, { type: 'buff', effect: 'empower', target: 'allies' }], weakness: 'DQLR', resistance: null, description: "Drains stability and empowers other errors. Weak to Purging." },
            'C': { name: 'Correlated Noise', hp: 80, speed: 5, svg: 'c_err_svg', attacks: [{ type: 'damage', power: 18, target: 'lq' }, { type: 'summon', enemyType: ['X', 'Z'], count: 1, target: 'self' }], weakness: null, resistance: null, description: "A complex error source, can summon basic errors." }
        };
        const SKILLS = {
            'analyze': { name: 'Analyze', cost: 2, target: 'enemy', effect: 'analyze', power: 0, description: "Scan error: reveals HP & status.", anim: 'scan' },
            'correct_x': { name: 'Correct X', cost: 5, target: 'enemy', effect: 'damage', power: 18, type: 'X', description: "Corrects X-type errors. Weak vs Z.", anim: 'beam_red' },
            'correct_z': { name: 'Correct Z', cost: 5, target: 'enemy', effect: 'damage', power: 18, type: 'Z', description: "Corrects Z-type errors. Weak vs X.", anim: 'beam_violet' },
            'purge_leakage': { name: 'Purge Leakage', cost: 8, target: 'enemy', effect: 'damage', power: 30, type: 'DQLR', description: "Effective vs Leakage Phantoms.", anim: 'cleanse_yellow' },
            'restore_coherence': { name: 'Restore Stability', cost: 10, target: 'ally', effect: 'heal', power: 30, type: 'DQLR', description: "Restores Stability (HP).", anim: 'heal_green' },
            'pinpoint': { name: 'Pinpoint', cost: 6, target: 'enemy', effect: 'status', statusType: 'measured', duration: 3, power: 0, description: "Mark error as 'Measured', lowering defense.", anim: 'target_lock' },
            'expose_weakness': { name: 'Expose Weakness', cost: 7, target: 'enemy', effect: 'reveal_weakness', power: 0, description: "Reveal error's weakness/resistance.", anim: 'scan_detailed' },
        };
        const WEAKNESS_CP_REFUND = 2; // CP refunded on hitting weakness

        // --- SVG Definitions --- (Simple placeholders, replace with cooler designs)
        const SVG_SPRITES = {
            'lq_svg': `<svg viewBox="0 0 100 100"><defs><radialGradient id="gradLQ" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#a5f3fc" stop-opacity="1"/><stop offset="100%" stop-color="#60a5fa" stop-opacity="1"/></radialGradient></defs><circle cx="50" cy="50" r="40" fill="url(#gradLQ)"/><circle cx="50" cy="50" r="45" fill="none" stroke="#a5f3fc" stroke-width="3" stroke-dasharray="5 5"><animate attributeName="stroke-dashoffset" values="0;100" dur="5s" repeatCount="indefinite"/></circle></svg>`,
            'dec_svg': `<svg viewBox="0 0 100 100"><path d="M50 10 L90 50 L50 90 L10 50 Z" fill="#a78bfa" stroke="#c4b5fd" stroke-width="3"/><path d="M50 20 L80 50 L50 80 L20 50 Z" fill="none" stroke="#1f2937" stroke-width="2"/></svg>`,
            'stab_svg': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="30" fill="none" stroke="#34d399" stroke-width="5"/><path d="M50 10 V30 M50 70 V90 M10 50 H30 M70 50 H90" stroke="#34d399" stroke-width="5"/><circle cx="50" cy="50" r="10" fill="#34d399"/></svg>`,
            'dqlr_svg': `<svg viewBox="0 0 100 100"><path d="M20 80 A 40 40 0 0 1 80 80 L 50 20 Z" fill="#fbbf24" stroke="#fcd34d" stroke-width="3"/><path d="M35 75 A 20 20 0 0 1 65 75 L 50 40 Z" fill="none" stroke="#1f2937" stroke-width="2"/></svg>`,
            'x_err_svg': `<svg viewBox="0 0 100 100"><path d="M20 20 L80 80 M80 20 L20 80" stroke="#f43f5e" stroke-width="12" stroke-linecap="round"/><path d="M25 25 L75 75 M75 25 L25 75" stroke="#fecdd3" stroke-width="4" stroke-linecap="round"/></svg>`,
            'z_err_svg': `<svg viewBox="0 0 100 100"><path d="M20 25 H80 L20 75 H80" stroke="#8b5cf6" stroke-width="12" fill="none" stroke-linejoin="round" stroke-linecap="round"/><path d="M25 30 H75 L25 70 H75" stroke="#ddd6fe" stroke-width="4" fill="none" stroke-linejoin="round" stroke-linecap="round"/></svg>`,
            'l_err_svg': `<svg viewBox="0 0 100 100"><path d="M50 10 C 20 30, 20 70, 50 90 C 80 70, 80 30, 50 10 Z" fill="#f59e0b" opacity="0.7"/><path d="M50 20 C 30 40, 30 60, 50 80 C 70 60, 70 40, 50 20 Z" fill="#1f2937" opacity="0.8"/></svg>`,
            'c_err_svg': `<svg viewBox="0 0 100 100"><circle cx="35" cy="35" r="20" fill="#ef4444"/><circle cx="65" cy="65" r="20" fill="#ef4444"/><path d="M45 45 L55 55" stroke="#f87171" stroke-width="8"/><circle cx="35" cy="35" r="25" stroke="#f87171" stroke-width="4" fill="none"/><circle cx="65" cy="65" r="25" stroke="#f87171" stroke-width="4" fill="none"/></svg>`
        };


        // --- Game State ---
        let playerTeam = [];
        let enemies = [];
        let turnOrder = [];
        let currentTurnIndex = 0;
        let selectedCharacterId = null;
        let selectedSkill = null;
        let selectedTargetId = null;
        let messageLog = [];
        let gameOver = false;

        // --- DOM Elements ---
        const playerSideEl = document.getElementById('player-side');
        const enemySideEl = document.getElementById('enemy-side');
        const skillButtonsEl = document.getElementById('skill-buttons');
        const messageLogEl = document.getElementById('message-log');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const restartBtn = document.getElementById('restart-btn');

        // --- Sound Initialization ---
        // ... (sound setup and play functions remain the same) ...
        function setupSounds() { synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination(); console.log("Audio context started."); soundEnabled = true; }
        function playSound(type) { if (!soundEnabled) return; try { const now = Tone.now(); switch(type) { case 'select': synth.triggerAttackRelease('C5', '32n', now); break; case 'confirm': synth.triggerAttackRelease('E5', '16n', now); break; case 'cancel': synth.triggerAttackRelease('C4', '16n', now); break; case 'player_attack': noiseSynth.triggerAttackRelease('8n', now); synth.triggerAttackRelease('A4', '8n', now + 0.01); break; case 'enemy_attack': noiseSynth.triggerAttackRelease('8n', now + 0.05); synth.triggerAttackRelease('D3', '8n', now + 0.06); break; case 'heal': synth.triggerAttackRelease('C6', '8n', now); break; case 'buff': synth.triggerAttackRelease('E5', '16n', now); synth.triggerAttackRelease('G5', '16n', now + 0.1); break; case 'debuff': synth.triggerAttackRelease('F#3', '8n', now); break; case 'weakness_hit': synth.triggerAttackRelease('B5', '8n', now); noiseSynth.triggerAttackRelease('16n', now + 0.02); break; case 'error_defeated': noiseSynth.triggerAttackRelease('4n', now); synth.triggerAttackRelease('C3', '4n', now + 0.05); break; case 'game_over': noiseSynth.triggerAttackRelease('1n', now); synth.triggerAttackRelease('A1', '1n', now); break; case 'battle_start': synth.triggerAttackRelease('C4', '8n'); synth.triggerAttackRelease('E4', '8n', now+0.2); synth.triggerAttackRelease('G4', '8n', now+0.4); break; } } catch (e) { console.error("Sound playback error:", e); } }
        function initAudio() { if (!soundEnabled && Tone.context.state !== 'running') { Tone.start().then(setupSounds); } else if (!soundEnabled && Tone.context.state === 'running') { setupSounds(); } window.removeEventListener('click', initAudio); window.removeEventListener('keydown', initAudio); }
        window.addEventListener('click', initAudio, { once: true }); window.addEventListener('keydown', initAudio, { once: true });


        // --- Game Logic Functions ---

        function startGame() {
            gameOver = false;
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('show');
            messageLog = [];
            logMessage("Quantum Battle Initialized!");

            playerTeam = JSON.parse(JSON.stringify(PLAYER_TEAM_CONFIG)); // Use config for reset
            enemies = [ createEnemy('X'), createEnemy('Z'), createEnemy('L') ];
            if (Math.random() < 0.2) enemies.push(createEnemy('X')); // Sometimes add extra

            setupTurnOrder();
            currentTurnIndex = -1; // Start before first turn
            selectedCharacterId = null;
            selectedSkill = null;
            selectedTargetId = null;

            drawBattleState();
            updateActionMenu();
            playSound('battle_start');
            setTimeout(nextTurn, 500);
        }

        function createEnemy(type) { /* ... remains the same ... */
             const base = ENEMY_TYPES[type]; if (!base) return null; return { ...JSON.parse(JSON.stringify(base)), id: `enemy_${type}_${Math.random().toString(16).slice(2)}`, currentHp: base.hp, statusEffects: [] };
        }

        function setupTurnOrder() { /* ... remains the same ... */
             turnOrder = [...playerTeam, ...enemies].sort((a, b) => b.speed - a.speed); console.log("Turn order:", turnOrder.map(u => u.name));
        }

        function getCurrentUnit() { /* ... remains the same ... */
             if (gameOver || turnOrder.length === 0) return null; return turnOrder[currentTurnIndex % turnOrder.length];
        }

        function nextTurn() {
            if (gameOver) return;
            console.log("Entering nextTurn"); // Debugging log

            // Clear previous turn states
            selectedSkill = null;
            selectedTargetId = null;
            const previousUnit = getCurrentUnit(); // Get unit *before* incrementing index
            if (previousUnit) {
                 const prevUnitEl = document.getElementById(previousUnit.id);
                 if (prevUnitEl) prevUnitEl.classList.remove('active-turn');
            }
            selectedCharacterId = null; // Clear selected character too

            // Apply status effects & check durations
            applyStatusEffects();

            // Check win/loss conditions *after* status effects
            if (enemies.length === 0) {
                endGame(true, "All errors corrected!");
                return;
            }
            const lq = playerTeam.find(c => c.type === 'LQ');
            if (!lq || lq.hp <= 0) {
                endGame(false, "Logical Qubit Decohered!");
                return;
            }

            // Increment turn index
            currentTurnIndex++;
            if (currentTurnIndex >= turnOrder.length) {
                currentTurnIndex = 0; // Loop back
                logMessage("--- New Round ---");
                playerTeam.forEach(p => { if(p.type !== 'LQ') p.cp = Math.min(p.maxCp, p.cp + 5); }); // CP Regen
            }

            const currentUnit = getCurrentUnit();
            if (!currentUnit) {
                 console.error("Error getting current unit after index update", currentTurnIndex, turnOrder);
                 logMessage("Error: Turn order desync?");
                 // Attempt recovery? Or end game?
                 // For now, try advancing again, might skip a turn.
                 setTimeout(nextTurn, 100);
                 return;
            }
            // Ensure unit still exists (wasn't defeated by status effect)
            const unitExists = playerTeam.some(p => p.id === currentUnit.id) || enemies.some(e => e.id === currentUnit.id);
             if (!unitExists) {
                 console.log(`Unit ${currentUnit.id} no longer exists, skipping turn.`);
                 // Turn order might be stale, re-setup and try again?
                 // Simple fix: just advance turn again
                 setTimeout(nextTurn, 100);
                 return;
             }


            logMessage(`Turn: ${currentUnit.name}`);

             // Highlight active unit
             const activeUnitEl = document.getElementById(currentUnit.id);
             if (activeUnitEl) activeUnitEl.classList.add('active-turn');
             else console.warn(`Element not found for active unit: ${currentUnit.id}`);


            if (playerTeam.some(p => p.id === currentUnit.id)) {
                // Player's turn
                selectedCharacterId = currentUnit.id;
                updateActionMenu();
            } else {
                // Enemy's turn
                updateActionMenu(); // Clear/disable player actions
                setTimeout(enemyAI, 1000); // Slightly longer delay for enemy action visibility
            }
             drawBattleState();
             console.log("Exiting nextTurn normally"); // Debugging log
        }

        function applyStatusEffects() { /* ... remains the same ... */
              [...playerTeam, ...enemies].forEach(unit => {
                  unit.statusEffects = unit.statusEffects?.filter(effect => { // Use optional chaining
                      let effectExpired = false;
                      switch(effect.effect) {
                          case 'decohere':
                              const lq = playerTeam.find(c => c.type === 'LQ');
                              if (lq && lq.hp > 0) { // Only apply if LQ alive
                                  const damage = Math.max(1, Math.floor(lq.maxHp * 0.05));
                                  lq.hp = Math.max(0, lq.hp - damage);
                                  logMessage(`${unit.name}'s ${effect.effect} damages LQ for ${damage} Stability!`);
                                  showEffectText(lq.id, `-${damage}`, 'damage');
                                   if (lq.hp <= 0) { // Check for defeat immediately after status damage
                                       logMessage("Logical Qubit Decohered due to status effect!");
                                       // endGame will be called in nextTurn check
                                   }
                              }
                              break;
                          // Other effects apply passively during calculation or expire
                      }
                      effect.duration--;
                      if(effect.duration <= 0) {
                          logMessage(`${unit.name}'s ${effect.effect} effect wore off.`);
                          effectExpired = true;
                      }
                      return !effectExpired; // Keep effect if duration > 0
                  }) || []; // Ensure statusEffects is always an array
              });
              // Redraw needed if HP changed due to status
              drawBattleState();
         }

        function enemyAI() { /* ... remains the same, ensure nextTurn is called ... */
             if (gameOver) return;
             const enemy = getCurrentUnit();
             // Add extra check: Is it really enemy's turn?
             if (!enemy || playerTeam.some(p => p.id === enemy.id)) {
                 console.warn("Enemy AI called, but it's not an enemy's turn?", enemy);
                 nextTurn(); // Try to recover
                 return;
             }
              // Ensure enemy still exists in the enemies array
              if (!enemies.some(e => e.id === enemy.id)) {
                  console.log(`Enemy ${enemy.name} was defeated before its action.`);
                  nextTurn();
                  return;
              }

             const availableAttacks = enemy.attacks;
             if (!availableAttacks || availableAttacks.length === 0) { logMessage(`${enemy.name} hesitates.`); setTimeout(nextTurn, 500); return; }
             const attack = availableAttacks[Math.floor(Math.random() * availableAttacks.length)];
             let target = null;
             // Targeting logic... (remains the same)
             if (attack.target === 'lq') { target = playerTeam.find(c => c.type === 'LQ'); }
             else if (attack.target === 'random_player') { const potentialTargets = playerTeam.filter(p => p.hp > 0); if (potentialTargets.length > 0) { target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)]; } }
             else if (attack.target === 'self') { target = enemy; }
             else if (attack.target === 'allies') { logMessage(`${enemy.name} empowers allies!`); playSound('buff'); setTimeout(nextTurn, 800); return; }
             else if (attack.type === 'summon') { /* Summon logic ... */ for (let i=0; i < attack.count; i++) { const typeToSummon = attack.enemyType[Math.floor(Math.random() * attack.enemyType.length)]; const newEnemy = createEnemy(typeToSummon); if (newEnemy && enemies.length < 4) { enemies.push(newEnemy); logMessage(`${enemy.name} summons a ${newEnemy.name}!`); turnOrder.push(newEnemy); } } drawBattleState(); setTimeout(nextTurn, 800); return; }

             if (target && target.hp > 0) {
                 logMessage(`${enemy.name} uses ${attack.type} on ${target.name}.`);
                 playSound('enemy_attack');
                 // Add animation trigger before executing action
                 animateAttack(enemy.id, target.id, 'enemy');
                 executeAction(enemy, attack, target); // Execute after short delay? or immediately?
             } else { logMessage(`${enemy.name} finds no valid target.`); }

             // Ensure nextTurn is called
             setTimeout(nextTurn, 1500); // Increased delay for enemy action visibility
        }

        function selectSkill(skillId) { /* ... remains the same ... */
             playSound('select'); const character = playerTeam.find(c => c.id === selectedCharacterId); const skill = SKILLS[skillId]; if (!character || !skill || character.cp < skill.cost) { return; } selectedSkill = skillId; logMessage(`Selected: ${skill.name}. Choose target.`); updateActionMenu(); drawBattleState();
        }

        function selectTarget(targetId) { /* ... remains the same ... */
             playSound('select'); if (!selectedSkill) { logMessage("Select a skill first!"); return; } selectedTargetId = targetId; logMessage(`Targeted: ${turnOrder.find(u=>u.id === targetId)?.name}. Confirm.`); updateActionMenu(); drawBattleState();
        }

        function confirmAction() { /* ... ensure nextTurn is called ... */
             playSound('confirm');
             const character = playerTeam.find(c => c.id === selectedCharacterId);
             const skill = SKILLS[selectedSkill];
             const target = turnOrder.find(u => u.id === selectedTargetId);

             if (character && skill && target && character.cp >= skill.cost) {
                 character.cp -= skill.cost;
                 logMessage(`${character.name} uses ${skill.name} on ${target.name}!`);
                 playSound('player_attack');
                 // Add animation trigger
                 animateAttack(character.id, target.id, 'player', skill.anim);
                 executeAction(character, skill, target); // Execute logic

                 selectedSkill = null; selectedTargetId = null;
                 updateActionMenu(); // Disable buttons
                 drawBattleState(); // Update CP etc.
                 setTimeout(nextTurn, 1500); // Delay after player action for animation
             } else { logMessage("Action failed."); playSound('cancel'); selectedSkill = null; selectedTargetId = null; updateActionMenu(); drawBattleState(); }
        }

        function executeAction(source, action, target) { /* ... weakness refund logic ... */
             let damage = 0; let effectApplied = false; let hitWeakness = false; let cpRefund = 0;
             let powerMultiplier = 1.0; source.statusEffects?.forEach(eff => { if (eff.effect === 'empower') powerMultiplier *= 1.5; });
             let defenseMultiplier = 1.0; target.statusEffects?.forEach(eff => { if (eff.effect === 'defense_down' || eff.effect === 'measured') defenseMultiplier *= (1 + (eff.power || 0.5)); }); // Measured adds 0.5 def down effectively

             switch(action.effect) {
                 case 'damage':
                     damage = Math.floor(action.power * powerMultiplier * defenseMultiplier);
                     const targetInfo = ENEMY_TYPES[target.type];
                     if (targetInfo) {
                         if (targetInfo.weakness === action.type) {
                             damage = Math.floor(damage * 1.6); // Increased weakness bonus
                             hitWeakness = true;
                             logMessage("Weakness hit!"); playSound('weakness_hit');
                             cpRefund = WEAKNESS_CP_REFUND; // Grant CP refund
                         } else if (targetInfo.resistance === action.type) { damage = Math.floor(damage * 0.5); logMessage("Resisted!"); }
                     }
                     target.hp = Math.max(0, target.hp - damage);
                     logMessage(`${target.name} takes ${damage} damage.`);
                     showEffectText(target.id, `-${damage}`, 'damage' + (hitWeakness ? ' weakness' : ''));
                     animateHit(target.id); // Add hit animation
                     if (target.hp <= 0) { handleDefeat(target); }
                     break;
                 case 'heal': /* ... heal logic ... */
                     const healAmount = Math.floor(action.power * powerMultiplier); target.hp = Math.min(target.maxHp, target.hp + healAmount); logMessage(`${target.name} recovers ${healAmount} Stability.`); playSound('heal'); showEffectText(target.id, `+${healAmount}`, 'heal');
                     break;
                 case 'status': // Includes defense_down, empower, measured etc.
                     const statusType = action.statusType || action.effect; // Use statusType if defined
                     target.statusEffects = target.statusEffects?.filter(eff => eff.effect !== statusType) || [];
                     target.statusEffects.push({ effect: statusType, duration: action.duration, power: action.power });
                     logMessage(`${target.name} is affected by ${statusType}!`);
                     playSound(statusType === 'empower' ? 'buff' : 'debuff');
                     showEffectText(target.id, `${statusType.toUpperCase()}!`, 'status');
                     effectApplied = true;
                     break;
                 case 'reveal_weakness': /* ... reveal logic ... */
                      const enemyTypeInfo = ENEMY_TYPES[target.type]; if (enemyTypeInfo) { logMessage(`${target.name} Weak: ${enemyTypeInfo.weakness || 'N/A'}. Res: ${enemyTypeInfo.resistance || 'N/A'}.`); showEffectText(target.id, `Weak: ${enemyTypeInfo.weakness || 'N/A'}`, 'status'); } else { logMessage(`Analysis failed.`); } playSound('buff'); effectApplied = true;
                     break;
                 case 'analyze': /* ... analyze logic ... */
                      logMessage(`${target.name} HP: ${target.hp}/${target.maxHp}`); showEffectText(target.id, `HP ${target.hp}/${target.maxHp}`, 'status'); playSound('buff'); effectApplied = true;
                     break;
             }
             // Apply CP refund if weakness was hit by player
             if (hitWeakness && playerTeam.some(p => p.id === source.id)) {
                 source.cp = Math.min(source.maxCp, source.cp + cpRefund);
                 logMessage(`${source.name} recovers ${cpRefund} CP!`);
                 showEffectText(source.id, `+${cpRefund} CP`, 'cp-gain');
             }
             drawBattleState(); // Update UI immediately after action logic
        }

         function handleDefeat(unit) { /* ... */
              logMessage(`${unit.name} is corrected!`);
              playSound('error_defeated');
              showEffectText(unit.id, 'Corrected!', 'heal');

              // Animate defeat before removing
              const unitElement = document.getElementById(unit.id);
              if (unitElement) {
                  unitElement.classList.add('defeated');
                  // Remove after animation
                  setTimeout(() => {
                       // Recalculate turn order *after* removing
                       enemies = enemies.filter(e => e.id !== unit.id);
                       // Recalculate turn order fully
                       setupTurnOrder();
                       // Adjust index carefully - find the *next* unit in the *new* order
                       const currentUnit = getCurrentUnit(); // Get unit before potential index change
                       currentTurnIndex = turnOrder.findIndex(u => u.id === currentUnit?.id);
                       // If current unit was defeated or not found, reset index?
                       if (currentTurnIndex === -1) currentTurnIndex = 0;

                       drawBattleState(); // Redraw without the defeated unit
                  }, 500); // Match defeat animation duration
              } else {
                   // Failsafe if element not found
                   enemies = enemies.filter(e => e.id !== unit.id);
                   setupTurnOrder();
                   currentTurnIndex = 0; // Reset index if unsure
                   drawBattleState();
              }
         }

         function showEffectText(targetId, text, typeClass = 'damage') { /* ... remains the same ... */
              const targetElement = document.getElementById(targetId); if (!targetElement) return; const effectEl = document.createElement('div'); effectEl.className = `effect-text ${typeClass}`; effectEl.textContent = text; document.getElementById('battle-area').appendChild(effectEl); const rect = targetElement.getBoundingClientRect(); const containerRect = document.getElementById('battle-area').getBoundingClientRect(); effectEl.style.left = `${rect.left - containerRect.left + rect.width / 2}px`; effectEl.style.top = `${rect.top - containerRect.top}px`; setTimeout(() => { effectEl.remove(); }, 1200);
         }

        function logMessage(message) { /* ... remains the same ... */
             console.log(message); messageLog.push(message); if (messageLog.length > MAX_LOG_MESSAGES * 2) { messageLog.shift(); } const logHtml = messageLog.slice(-MAX_LOG_MESSAGES).map(m => `<p>${m}</p>`).join(''); messageLogEl.innerHTML = logHtml; messageLogEl.scrollTop = messageLogEl.scrollHeight;
        }

        // --- Drawing & Animation Functions ---
        function drawBattleState() { /* ... draw units ... */
             playerSideEl.innerHTML = ''; playerTeam.forEach(p => playerSideEl.appendChild(createUnitElement(p, true)));
             enemySideEl.innerHTML = ''; enemies.forEach(e => enemySideEl.appendChild(createUnitElement(e, false)));
             // Highlight logic remains the same
             document.querySelectorAll('.enemy, .character').forEach(el => el.classList.remove('targeted')); if (selectedSkill && selectedTargetId) { const targetEl = document.getElementById(selectedTargetId); if (targetEl) targetEl.classList.add('targeted'); } else if (selectedSkill) { const skillInfo = SKILLS[selectedSkill]; const potentialTargets = turnOrder.filter(unit => { if (skillInfo.target === 'enemy') return enemies.some(e => e.id === unit.id); if (skillInfo.target === 'ally') return playerTeam.some(p => p.id === unit.id); if (skillInfo.target === 'self') return unit.id === selectedCharacterId; return false; }); potentialTargets.forEach(unit => { const el = document.getElementById(unit.id); if (el) el.classList.add('targeted'); }); }
             // Highlight active character AFTER drawing
             const currentUnit = getCurrentUnit();
             if (currentUnit) {
                  const activeUnitEl = document.getElementById(currentUnit.id);
                  if (activeUnitEl) activeUnitEl.classList.add('active-turn');
             }
        }

        function createUnitElement(unit, isPlayer) { /* ... create unit DOM ... */
             const container = document.createElement('div'); // Container for positioning effects
             container.className = 'unit-container';
             container.id = unit.id; // ID on container now

             const div = document.createElement('div');
             div.className = `unit ${isPlayer ? 'character' : 'enemy'} ${isPlayer ? 'char-' + unit.type : 'enemy-' + unit.type}`;
             if (!isPlayer) { div.onclick = () => { if(selectedSkill) selectTarget(unit.id); }; div.style.cursor = selectedSkill ? 'pointer' : 'default'; }
             else { div.onclick = () => { if(selectedSkill && SKILLS[selectedSkill].target === 'ally') selectTarget(unit.id); }; div.style.cursor = (selectedSkill && SKILLS[selectedSkill].target === 'ally') ? 'pointer' : 'default'; }

             // SVG Sprite
             const spriteDiv = document.createElement('div');
             spriteDiv.className = 'unit-sprite';
             spriteDiv.innerHTML = SVG_SPRITES[unit.svg || (isPlayer ? 'lq_svg' : 'x_err_svg')]; // Use SVG map
             div.appendChild(spriteDiv);

             const name = document.createElement('div'); name.className = 'text-sm font-semibold'; name.textContent = unit.name; div.appendChild(name);
             const hpContainer = document.createElement('div'); hpContainer.className = 'hp-bar-container'; const hpBar = document.createElement('div'); hpBar.className = 'hp-bar'; hpBar.style.width = `${Math.max(0, (unit.hp / unit.maxHp) * 100)}%`; hpContainer.appendChild(hpBar); div.appendChild(hpContainer); const hpText = document.createElement('div'); hpText.className = 'text-xs text-gray-400'; hpText.textContent = `${unit.hp}/${unit.maxHp}`; div.appendChild(hpText);
             if (isPlayer && unit.type !== 'LQ') { const cpContainer = document.createElement('div'); cpContainer.className = 'cp-bar-container'; const cpBar = document.createElement('div'); cpBar.className = 'cp-bar'; cpBar.style.width = `${Math.max(0, (unit.cp / unit.maxCp) * 100)}%`; cpContainer.appendChild(cpBar); div.appendChild(cpContainer); const cpText = document.createElement('div'); cpText.className = 'text-xs text-gray-400'; cpText.textContent = `${unit.cp}/${unit.maxCp}`; div.appendChild(cpText); }

             // Status Effects Icons Container
             const statusIconsContainer = document.createElement('div');
             statusIconsContainer.className = 'status-effect-icons';
             unit.statusEffects?.forEach(eff => { /* ... status icon logic ... */
                  const statusIcon = document.createElement('i'); let iconClass = ''; let colorClass = '';
                  switch(eff.effect) { case 'decohere': iconClass = 'fa-arrow-trend-down'; colorClass = 'text-red-500'; break; case 'defense_down': case 'measured': iconClass = 'fa-shield-slash'; colorClass = 'text-yellow-500'; break; case 'empower': iconClass = 'fa-bolt'; colorClass = 'text-blue-400'; break; }
                  if (iconClass) { statusIcon.className = `fas ${iconClass} ${colorClass} status-effect`; statusIcon.title = `${eff.effect} (${eff.duration} turns left)`; statusIconsContainer.appendChild(statusIcon); }
             });
             container.appendChild(statusIconsContainer); // Add icons container
             container.appendChild(div); // Add unit div
             return container; // Return the container
        }

        function updateActionMenu() { /* ... update buttons based on state ... */
             skillButtonsEl.innerHTML = ''; const character = playerTeam.find(c => c.id === selectedCharacterId);
             if (character && character.type !== 'LQ') {
                 character.skills.forEach(skillId => { const skill = SKILLS[skillId]; if (!skill) return; const button = document.createElement('button'); button.className = 'action-button'; button.textContent = `${skill.name} (${skill.cost} CP)`; button.disabled = character.cp < skill.cost || !!selectedSkill; button.onclick = () => selectSkill(skillId); skillButtonsEl.appendChild(button); });
                 if (selectedSkill && selectedTargetId) { const confirmBtn = document.createElement('button'); confirmBtn.className = 'action-button bg-green-600 hover:bg-green-700'; confirmBtn.textContent = 'Confirm'; confirmBtn.onclick = confirmAction; skillButtonsEl.appendChild(confirmBtn); const cancelBtn = document.createElement('button'); cancelBtn.className = 'action-button bg-gray-500 hover:bg-gray-600'; cancelBtn.textContent = 'Cancel'; cancelBtn.onclick = () => { playSound('cancel'); selectedSkill = null; selectedTargetId = null; updateActionMenu(); drawBattleState(); logMessage("Action cancelled."); }; skillButtonsEl.appendChild(cancelBtn); }
                 else if (selectedSkill) { // Skill selected, waiting for target
                      skillButtonsEl.innerHTML = `<p class="w-full text-center text-sm text-yellow-400">Select Target for ${SKILLS[selectedSkill].name}...</p>`;
                      const cancelBtn = document.createElement('button'); cancelBtn.className = 'action-button bg-gray-500 hover:bg-gray-600'; cancelBtn.textContent = 'Cancel Skill'; cancelBtn.onclick = () => { playSound('cancel'); selectedSkill = null; updateActionMenu(); drawBattleState(); logMessage("Skill cancelled."); }; skillButtonsEl.appendChild(cancelBtn);
                 }
             } else { skillButtonsEl.innerHTML = '<p class="w-full text-center text-sm text-gray-400">Waiting for turn...</p>'; }
        }

        // --- Simple Animation Functions ---
        function animateAttack(sourceId, targetId, attackerType, animType = 'default') {
            const sourceEl = document.getElementById(sourceId)?.querySelector('.unit'); // Get inner unit div
            const targetEl = document.getElementById(targetId)?.querySelector('.unit');
            if (!sourceEl || !targetEl) return;

            // Simple lunge animation for attacker
            sourceEl.style.transition = 'transform 0.1s ease-out';
            const direction = (attackerType === 'player') ? 1 : -1;
            sourceEl.style.transform = `translateX(${direction * 20}px) scale(1.05)`; // Lunge forward

            // Reset attacker position after a delay
            setTimeout(() => {
                sourceEl.style.transform = ''; // Reset transform
            }, 150);

            // Target hit animation is handled by animateHit called from executeAction
        }

         function animateHit(targetId) {
            const targetEl = document.getElementById(targetId)?.querySelector('.unit');
             if (targetEl) {
                 targetEl.classList.add('hit');
                 setTimeout(() => targetEl.classList.remove('hit'), 300); // Duration matches CSS animation
             }
         }

        function endGame(isWin, message) { /* ... remains the same ... */
              if (gameOver) return; gameOver = true; playSound('game_over'); console.log("Game Over:", message); gameOverTitle.textContent = isWin ? "Correction Complete!" : "Logical Error!"; gameOverMessage.textContent = message; gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('show');
        }


        // --- Initialization ---
        restartBtn.addEventListener('click', () => { playSound('click'); startGame(); });
        document.addEventListener('DOMContentLoaded', startGame);

    </script>

</body>
</html>
